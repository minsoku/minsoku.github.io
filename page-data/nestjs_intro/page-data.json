{"componentChunkName":"component---src-templates-blog-template-js","path":"/nestjs_intro/","result":{"data":{"cur":{"id":"7d83a617-af6b-5e99-98ac-405303db1e5a","html":"<h1 id=\"nestjs-소개\" style=\"position:relative;\"><a href=\"#nestjs-%EC%86%8C%EA%B0%9C\" aria-label=\"nestjs 소개 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Nestjs 소개</h1>\n<ul>\n<li>Nestjs는 효율적이고 스케일링이 쉬운 nodejs 서버를 만드는데 사용하는 프레임워크이다.</li>\n<li>차세대 Javascript를 사용하며 Typescript로 만들어졌으며 Typescript를 완전히 지원한다.</li>\n<li>Nestjs는 Express 같은 견고한 HTTP 서버 프레임워크를 사용하고 있으며 원한다면 Fastify를 대신 사용할 수 있다.</li>\n<li>상당히 많은 Nodejs 라이브러리, 헬퍼, 툴들이 있음에도 불구하고 아키텍처 설계에 대한 문제를 해결해주는 해결책은 존재하지 않는다.</li>\n<li>Nestjs는 자체적으로 서버 아키텍쳐를 제공해준다. 그래서 테스트하기 쉽고, 디커플링이 잘 되어있고, 유지보수가 편한 서버를 제작하게 해준다.</li>\n</ul>\n<h1 id=\"nestjs-lifecycle\" style=\"position:relative;\"><a href=\"#nestjs-lifecycle\" aria-label=\"nestjs lifecycle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Nestjs LifeCycle</h1>\n<p><img src=\"https://velog.velcdn.com/images/minsoku03/post/b67672cd-fdea-4067-ab80-02e15b3ffdb3/image.png\" alt=\"\"></p>\n<h2 id=\"pipe\" style=\"position:relative;\"><a href=\"#pipe\" aria-label=\"pipe permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pipe</h2>\n<ul>\n<li>파이프는 클래스인데 @Injectable()로  데코레이터 되어있고, 그리고 Pipe transform이라는 인터페이스를 implement한다.</li>\n<li>변형: 원하는 형태로 변형시켜준다 ex) string => integer</li>\n<li>검증: 만약에 유효한 데이터면 그대로 전달해주고 아닐 경우에는 에러를 던진다.</li>\n</ul>\n<h3 id=\"코드-예시\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C-%EC%98%88%EC%8B%9C\" aria-label=\"코드 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드 예시</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">test.pipe.ts\n\nimport {\n    ArgumentMetadata,\n    BadRequestException,\n    Injectable,\n    PipeTransform,\n} from '@nestjs/common';\n\n@Injectable()\nexport class TestPipe implements PipeTransform {\n    transform(value: any, metadata: ArgumentMetadata) {\n        if (value.content.toString().length > 10) {\n            throw new BadRequestException(\n                'content는 10자 미만으로 작성해주세요',\n            );\n        }\n        return value.toString();\n    }\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.controller.ts\n\n@Controller()\nexport class AppController {\n    constructor(private readonly appService: AppService) {}\n\n    @Get()\n    @UsePipes(TestPipe)\n    getHello(@Body() body: Ibody): string {\n        console.log(body);\n        return '성공';\n    }\n}</code></pre></div>\n<h3 id=\"결과\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EA%B3%BC\" aria-label=\"결과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결과</h3>\n<p><img src=\"https://velog.velcdn.com/images/minsoku03/post/4e1ca450-f607-4b58-948e-a60084e68e33/image.png\" alt=\"\"></p>\n<h2 id=\"guard\" style=\"position:relative;\"><a href=\"#guard\" aria-label=\"guard permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Guard</h2>\n<ul>\n<li>Guard는 쉽게 말하면 보호하는 역할</li>\n<li>Guard는 api 요청이 들어갔을 때 (Controller, Service, Repository) 로직 처리 부분까지 갈 수 있냐 없냐를 결정하게 해주는 요소다.</li>\n<li>Pipe가 적용이 되기 훨씬 전에 Guard가 먼저 적용이 돼서 만약에 Guard에서 이번 요청은 들어갈 수가 없어라고 판단을 한다면 파이프까지의 요청이 이어지지도 않는다.</li>\n<li>Guard를 구현하는 것은 Pipe를 구현하는 것과 굉장히 비슷하다.</li>\n<li>Injectable 클래스를 사용해서 만들고, CanActivate라는 타입을 implement를 해준다.</li>\n</ul>\n<h3 id=\"코드-예시-1\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C-%EC%98%88%EC%8B%9C-1\" aria-label=\"코드 예시 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드 예시</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">test.guard.ts\n\nimport {\n    CanActivate,\n    ExecutionContext,\n    Injectable,\n    UnauthorizedException,\n} from '@nestjs/common';\n\n@Injectable()\nexport class TestGuard implements CanActivate {\n    canActivate(context: ExecutionContext): boolean {\n        const req = context.switchToHttp().getRequest();\n        const token = req.headers['authorization'];\n        if (!token) {\n            throw new UnauthorizedException('토큰이 없습니다 !!!!');\n        }\n        return true;\n    }\n}\n</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.controller.ts\n\n@Controller()\nexport class AppController {\n    constructor(private readonly appService: AppService) {}\n    @Get()\n    @UsePipes(TestPipe)\n    @UseGuards(TestGuard)\n    getHello(@Body() body: Ibody): string {\n        console.log(body);\n        return '성공';\n    }\n}</code></pre></div>\n<h3 id=\"결과-1\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EA%B3%BC-1\" aria-label=\"결과 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결과</h3>\n<ul>\n<li>Autorization을 안 넣었을 때</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/minsoku03/post/a5f9eeaa-ab9d-4efa-b469-31c4d57451dd/image.png\" alt=\"\"></p>\n<ul>\n<li>Autorization을 넣었을 때</li>\n</ul>\n<p><img src=\"https://velog.velcdn.com/images/minsoku03/post/ae49af58-8478-480c-8742-968275504912/image.png\" alt=\"\"></p>","excerpt":"Nestjs 소개 Nestjs는 효율적이고 스케일링이 쉬운 nodejs 서버를 만드는데 사용하는 프레임워크이다. 차세대 Javascript를 사용하며 Typescript로 만들어졌으며 Typescript를 완전히 지원한다. Nestjs는 Express 같은 견고한 HTTP 서버 프레임워크를 사용하고 있으며 원한다면 Fastify를 대신 사용할 수 있다. 상당히 많은 Nodejs 라이브러리, 헬퍼, 툴들이 있음에도 불구하고 아키텍처 설계에 대한 문제를 해결해주는 해결책은 존재하지 않는다. Nestjs는 자체적으로 서버 아키텍쳐를 제공해준다. 그래서 테스트하기 쉽고, 디커플링이 잘 되어있고, 유지보수가 편한 서버를 제작하게 해준다. Nestjs LifeCycle  Pipe 파이프는 클래스인데 @Injectable()로  데코레이터 되어있고, 그리고 Pipe transform이라는 인터페이스를 implement한다. 변형: 원하는 형태로 변형시켜준다 ex) string => intege…","frontmatter":{"date":"December 10, 2023","title":"Nestjs 소개 및 라이프사이클","categories":"nestjs","author":"minsoku","emoji":""},"fields":{"slug":"/nestjs_intro/"}},"next":null,"prev":null},"pageContext":{"slug":"/nestjs_intro/","nextSlug":"","prevSlug":""}},"staticQueryHashes":["1956554647","2938748437"]}